def read_data(filename):
    '''
    Чтение двумерного массива из файла filename в список списков pole
    '''
    with open(filename) as file:
        pole = [list(line.replace("\n", "").split()) for line in file]
    return pole

def who_play_now(pole):
    '''
    Ищет крестики и нолики и делает их подсчет, чтобы понять кто сейчас ходит.
    Если количество крестиков и нулей равны, то ходят крестики.
    В другом случае ходят нолики

    pole -- игровое поле
    '''
    count_krest = 0 #счетчик количества крестиков
    count_null = 0 #счетчик количества ноликов
    for i in range(3):
        for j in range(3):
            if pole[i][j] == "X":
                count_krest += 1
            elif pole[i][j] == "0":
                count_null += 1
    if count_krest == count_null:
        playing_now = 1
    else:
        playing_now = 0
    return playing_now #Возвращаем перемнную, если она равна 1, то ходят крестики, если ноль, то нолики

def check_for_win(pole, playing_now):
    '''
    Данная функция, исходя от полученной переменной в функции who_play_now, обходит всю матрицу
    и проверяет каждую ячейку на наличие крестика или нолика, а затем проверяет ряды по вертикали,
    горизонтали и, если ячейка находится на главной или побочной диагонали, то проверяет диагональ
    или диагонали, если надо. В итоге, если в ряду 2 одинаковых знака и третья ячейка пуста, то функция
    возвращает список с значениями -1, индексом строчки, столбика или 1. Индекс значения в списке
    важен для понимания к чему это значение нужно отнести, к ряду по вертикали, горизонтали или диагонали
    соответственно.

    pole -- игровое поле
    playing_now -- в переменной указана сторона, которая сейчас ходит
    '''
    ind_i = -1 #Индекс строки для ряда по горизонтали
    ind_j = -1 #Индекс столбика для ряда по вертикали
    ind_main_diag = -1 #Если переменная равна -1, то главная диагональ нам не подходит, если равна 1 то подходит
    ind_poboch_diag = -1 #Если переменная равна -1, то побочная диагональ нам не подходит, если равна 1 то подходит
    if playing_now == 1: #Если ходят крестики
        for i in range(3):
            for j in range(3):
                if pole[i][j] == "X": #если в ячейке крестик
                    count_in_row_i = 0 #количество крестиков в строчке
                    count_in_row_j = 0 #количество крестиков в столбце
                    h_i = 1 #если равна 0, то в строчке находится посторонний знак
                    h_j = 1 #если равна 0, то в столбике находится посторонний знак
                    h_poboch_diag = 1 #если равна 0, то на побочной диагонали находится посторонний знак
                    h_diag_main = 1 #если равна 0, то на главной диагонали находится посторонний знак
                    count_main_diag = 0 #счетчик крестиков на главной диагонали
                    count_poboch_diag = 0 #счетчик крестиков на побочной диагонали
                    for k in range(3):
                        if pole[k][j] == "X": #если в ячейке крестик
                            count_in_row_i += 1
                        elif pole[k][j] == "0": #если в ячейке нолик
                            h_i = 0
                        if pole[i][k] == "X": #если в ячейке крестик
                            count_in_row_j += 1
                        elif pole[i][k] == "0": #если в ячейке нолик
                            h_j = 0
                    if count_in_row_i == 2 and h_i != 0: #Если в строчке 2 крестика и нет постороннего знака
                        ind_j = j
                        break
                    elif count_in_row_j == 2 and h_j != 0: #Если в столбике 2 крестика и нет постороннего знака
                        ind_i = i
                        break
                    if i == j: #если ячейка находится на главной диагонали
                        for p in range(3):
                            for l in range(3):
                                if p == l and pole[p][l] == "X": #если главная диагональ и в ячейке крестик
                                    count_main_diag += 1
                                elif p == l and pole[p][l] == "0": #если главная диагональ и в ячейке нолик
                                    h_diag_main = 0
                        if count_main_diag == 2 and h_diag_main != 0: #Если на главной диагонали 2 крестика и нет постороннего знака
                            ind_main_diag = 1
                            break
                    if j == 3 - i - 1: #если ячейка находится на побочной диагонали
                        for m in range(3):
                            for n in range(3):
                                if n == 3 - m - 1 and pole[m][n] == "X": #если побочная диагональ и в ячейке крестик
                                    count_poboch_diag += 1
                                elif n == 3 - m - 1 and pole[m][n] == "0": #если побочная диагональ и в ячейке нолик
                                    h_poboch_diag = 0
                        if count_poboch_diag == 2 and h_poboch_diag != 0: #Если на побочной диагонали 2 крестика и нет постороннего знака
                            ind_poboch_diag = 1
                            break
                if ind_i != -1 or ind_j != -1 or ind_main_diag != -1 or ind_poboch_diag != -1: #завершает цикл если мы нашли подходящий ряд
                    break
            if ind_i != -1 or ind_j != -1 or ind_main_diag != -1 or ind_poboch_diag != -1: #завершает цикл если мы нашли подходящий ряд
                break
    if playing_now == 0: #Если ходят нолики
        for i in range(3):
            for j in range(3):
                if pole[i][j] == "0": #если в ячейке нолик
                    count_in_row_i = 0 #количество ноликов в строчке
                    count_in_row_j = 0 #количество ноликов в столбце
                    h_i = 1 #если равна 0, то в строчке находится посторонний знак
                    h_j = 1 #если равна 0, то в столбике находится посторонний знак
                    h_poboch_diag = 1 #если равна 0, то на побочной диагонали находится посторонний знак
                    h_diag_main = 1 #если равна 0, то на главной диагонали находится посторонний знак
                    count_main_diag = 0 #счетчик ноликов на главной диагонали
                    count_poboch_diag = 0 #счетчик ноликов на побочной диагонали
                    for k in range(3):
                        if pole[k][j] == "0": #если в ячейке нолик
                            count_in_row_i += 1
                        elif pole[k][j] == "X": #если в ячейке крестик
                            h_i = 0
                        if pole[i][k] == "0": #если в ячейке нолик
                            count_in_row_j += 1
                        elif pole[i][k] == "X": #если в ячейке крестик
                            h_j = 0
                    if count_in_row_i == 2 and h_i != 0: #Если в строчке 2 нолика и нет постороннего знака
                        ind_j = j
                        break
                    elif count_in_row_j == 2 and h_j != 0: #Если в строчке 2 нолика и нет постороннего знака
                        ind_i = i
                        break
                    if i == j: #если ячейка находится на главной диагонали
                        for p in range(3):
                            for l in range(3):
                                if p == l and pole[p][l] == "0": #если главная диагональ и в ячейке нолик
                                    count_main_diag += 1
                                elif p == l and pole[p][l] == "X": #если главная диагональ и в ячейке крестик
                                    h_diag_main = 0
                        if count_main_diag == 2 and h_diag_main != 0: #Если на главной диагонали 2 нолика и нет постороннего знака
                            ind_main_diag = 1
                            break
                    if j == 3 - i - 1: #если ячейка находится на побочной диагонали
                        for m in range(3):
                            for n in range(3):
                                if n == 3 - m - 1 and pole[m][n] == "0": #если побочная диагональ и в ячейке нолик
                                    count_poboch_diag += 1
                                elif n == 3 - m - 1 and pole[m][n] == "X": #если побочная диагональ и в ячейке крестик
                                    h_poboch_diag = 0
                        if count_poboch_diag == 2 and h_poboch_diag != 0: #Если на побочной диагонали 2 нолика и нет постороннего знака
                            ind_poboch_diag = 1
                            break
                if ind_i != -1 or ind_j != -1 or ind_main_diag != -1 or ind_poboch_diag != -1: #завершает цикл если мы нашли подходящий ряд
                    break
            if ind_i != -1 or ind_j != -1 or ind_main_diag != -1 or ind_poboch_diag != -1: #завершает цикл если мы нашли подходящий ряд
                break
    maybe_ind = [ind_i, ind_j, ind_main_diag, ind_poboch_diag]
    return maybe_ind #Возарщает список с значениями -1, индексом строчки, столбика или 1. Индекс значения в списке
    # важен для понимания к чему это значение нужно отнести, к ряду по вертикали, горизонтали или диагонали соответственно.

def swap_a_row(pole, maybe_ind):
    '''
    Функция, котрая меняет победный ряд на знак $ при момощи значений из списка maybe_ind

    pole -- игровое поле
    maybe_ind -- список с индексами и значениями
    '''
    for l in range(len(maybe_ind)):
        if maybe_ind[l] != -1: #Если ряд нам подошёл
            if l == 0: #Если этот ряд по вертикали
                for j in range(3):
                    pole[maybe_ind[0]][j] = "$" #берем индекс строки
            if l == 1: #Если этот ряд по горизонтали
                for i in range(3):
                    pole[i][maybe_ind[1]] = "$" #берем индекс столбца
            if l == 2: #Если этот ряд - главная диагональ
                for j in range(3):
                    pole[j][j] = "$" #заполнение главной диагонали
            if l == 3: #Если этот ряд - побочная диагональ
                for i in range(3):
                    for j in range(3):
                        if j == 3 - i - 1:
                            pole[i][j] = "$" #заполнение побочной диагонали
    return pole #возвращаем поле с изменённой победной линией


def print_matrix(pole):
    '''
    выводит список списков(матрицу) в виде таблицы

    pole -- игровое поле(матрица)
    '''
    if pole:
        for i in range(3):
            for j in range(3):
                print(pole[i][j], end = " ")
            print()
def main():
    '''
    Основная функция программы.

    pole -- двумерный массив (список списков) игрового поля
    pole[i][j] -- точка игрового поля с координатами (i,j)
    i -- это номер строки с отсчетом сверху-вниз
    j -- это номер столбца с отсчетом слева-направо
    '''
    pole = read_data("input.txt") #Считываем лабиринт из файла
    playing_now = who_play_now(pole) #Узнаём чей сейчас ход
    maybe_ind = check_for_win(pole,playing_now) #Проверяем всю матрицу на победные линии
    pole = swap_a_row(pole,maybe_ind) #Заменяем победную линию на знак $
    print_matrix(pole) #Выводим список списков(матрицу) в виде таблицы

main()




